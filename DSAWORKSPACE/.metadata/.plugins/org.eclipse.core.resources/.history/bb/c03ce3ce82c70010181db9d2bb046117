package com.tcs.roundii;
import java.io.*;
import java.util.*;

public class MinimumHoles {

    static class FastScanner {
        BufferedReader br;
        StringTokenizer st;
        FastScanner(InputStream is) { br = new BufferedReader(new InputStreamReader(is)); }
        String next() throws IOException {
            while (st == null || !st.hasMoreElements()) st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }
        int nextInt() throws IOException { return Integer.parseInt(next()); }
    }

    public static void main(String[] args) throws Exception {
        FastScanner fs = new FastScanner(System.in);

        int n = fs.nextInt();  // width (x)
        int m = fs.nextInt();  // height (y)

        int N = fs.nextInt();

        List<int[]> vertical = new ArrayList<>();
        List<int[]> horizontal = new ArrayList<>();

        TreeSet<Integer> xsSet = new TreeSet<>();
        TreeSet<Integer> ysSet = new TreeSet<>();
        xsSet.add(0); xsSet.add(n);
        ysSet.add(0); ysSet.add(m);

        for (int i = 0; i < N; i++) {
            int x1 = fs.nextInt(), y1 = fs.nextInt(), x2 = fs.nextInt(), y2 = fs.nextInt();
            if (!((x1 == x2) ^ (y1 == y2))) { 
                System.out.println("Invalid");
                return;
            }
            if (x1 < 0 || x1 > n || x2 < 0 || x2 > n || y1 < 0 || y1 > m || y2 < 0 || y2 > m) {
                System.out.println("Invalid");
                return;
            }

            if (x1 == x2) {
                int x = x1;
                int a = Math.min(y1, y2), b = Math.max(y1, y2);
                vertical.add(new int[]{x, a, b});
                xsSet.add(x);
                ysSet.add(a); ysSet.add(b);
            } else { 
                int y = y1;
                int a = Math.min(x1, x2), b = Math.max(x1, x2);
                horizontal.add(new int[]{y, a, b});
                ysSet.add(y);
                xsSet.add(a); xsSet.add(b);
            }
        }

        // discretize
        int[] xs = xsSet.stream().mapToInt(Integer::intValue).toArray();
        int[] ys = ysSet.stream().mapToInt(Integer::intValue).toArray();
        int W = xs.length - 1; // number of cell columns
        int H = ys.length - 1; // number of cell rows
        if (W <= 0 || H <= 0) {
            System.out.println("Invalid");
            return;
        }

        // maps: coordinate -> index in xs/ys
        HashMap<Integer,Integer> xIndex = new HashMap<>();
        HashMap<Integer,Integer> yIndex = new HashMap<>();
        for (int i = 0; i < xs.length; i++) xIndex.put(xs[i], i);
        for (int j = 0; j < ys.length; j++) yIndex.put(ys[j], j);

        // walls on boundaries between cells:
        // vertical walls between col i and i+1, row j
        boolean[][] vWall = new boolean[W - 0][H];
        // horizontal walls between row j and j+1, col i
        boolean[][] hWall = new boolean[W][H - 0];

        // mark given segments as walls
        for (int[] v : vertical) {
            int x = v[0], y1 = v[1], y2 = v[2];
            Integer k = xIndex.get(x);
            if (k == null || k == 0 || k == xs.length - 1) {
                // lies on the outer border; we don't need to record outer border as internal wall
                // (holes on outer frame don't help cover two partitions)
            }
            int colBoundary = k - 1; // between col (k-1) and k
            for (int j = yIndex.get(y1); j < yIndex.get(y2); j++) {
                if (colBoundary >= 0 && colBoundary < W) vWall[colBoundary][j] = true;
            }
        }
        for (int[] h : horizontal) {
            int y = h[0], x1 = h[1], x2 = h[2];
            Integer k = yIndex.get(y);
            int rowBoundary = k - 1; // between row (k-1) and k
            for (int i = xIndex.get(x1); i < xIndex.get(x2); i++) {
                if (rowBoundary >= 0 && rowBoundary < H) hWall[i][rowBoundary] = true;
            }
        }

        // find connected components (partitions)
        int[][] comp = new int[W][H];
        for (int[] a : comp) Arrays.fill(a, -1);
        int compCnt = 0;

        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};

        // store info per component
        List<Integer> minI = new ArrayList<>(), maxI = new ArrayList<>();
        List<Integer> minJ = new ArrayList<>(), maxJ = new ArrayList<>();
        List<Integer> count = new ArrayList<>();
        List<int[]> repr = new ArrayList<>();

        for (int i = 0; i < W; i++) {
            for (int j = 0; j < H; j++) {
                if (comp[i][j] != -1) continue;
                // BFS
                int id = compCnt++;
                Queue<int[]> q = new ArrayDeque<>();
                q.add(new int[]{i, j});
                comp[i][j] = id;
                int mi = i, maI = i, mj = j, maJ = j, cells = 0;
                int[] rep = new int[]{i, j};
                while (!q.isEmpty()) {
                    int[] cur = q.poll();
                    int x = cur[0], y = cur[1];
                    cells++;
                    mi = Math.min(mi, x);
                    maI = Math.max(maI, x);
                    mj = Math.min(mj, y);
                    maJ = Math.max(maJ, y);

                    // right neighbor
                    if (x + 1 < W && !vWall[x][y]) {
                        if (comp[x + 1][y] == -1) { comp[x + 1][y] = id; q.add(new int[]{x + 1, y}); }
                    }
                    // left neighbor
                    if (x - 1 >= 0 && !vWall[x - 1][y]) {
                        if (comp[x - 1][y] == -1) { comp[x - 1][y] = id; q.add(new int[]{x - 1, y}); }
                    }
                    // up neighbor
                    if (y + 1 < H && !hWall[x][y]) {
                        if (comp[x][y + 1] == -1) { comp[x][y + 1] = id; q.add(new int[]{x, y + 1}); }
                    }
                    // down neighbor
                    if (y - 1 >= 0 && !hWall[x][y - 1]) {
                        if (comp[x][y - 1] == -1) { comp[x][y - 1] = id; q.add(new int[]{x, y - 1}); }
                    }
                }
                minI.add(mi); maxI.add(maI);
                minJ.add(mj); maxJ.add(maJ);
                count.add(cells);
                repr.add(rep);
            }
        }

        // validate each component is a perfect rectangle
        for (int id = 0; id < compCnt; id++) {
            int wi = maxI.get(id) - minI.get(id) + 1;
            int hi = maxJ.get(id) - minJ.get(id) + 1;
            if (wi * hi != count.get(id)) {
                System.out.println("Invalid");
                return;
            }
        }

        // build adjacency graph of partitions via INTERNAL walls
        ArrayList<HashSet<Integer>> g = new ArrayList<>();
        for (int i = 0; i < compCnt; i++) g.add(new HashSet<>());

        // vertical internal boundaries
        for (int i = 0; i < W - 1; i++) {
            for (int j = 0; j < H; j++) {
                if (vWall[i][j]) {
                    int a = comp[i][j], b = comp[i + 1][j];
                    if (a != b) { g.get(a).add(b); g.get(b).add(a); }
                }
            }
        }
        // horizontal internal boundaries
        for (int i = 0; i < W; i++) {
            for (int j = 0; j < H - 1; j++) {
                if (hWall[i][j]) {
                    int a = comp[i][j], b = comp[i][j + 1];
                    if (a != b) { g.get(a).add(b); g.get(b).add(a); }
                }
            }
        }

        // bipartition by parity of representative cell (i + j) % 2
        ArrayList<Integer> leftNodes = new ArrayList<>();
        int[] side = new int[compCnt]; // 0=left,1=right
        Arrays.fill(side, -1);
        for (int id = 0; id < compCnt; id++) {
            int[] r = repr.get(id);
            int s = ((r[0] + r[1]) & 1);
            side[id] = s; // 0 or 1
            if (s == 0) leftNodes.add(id);
        }

        // Hopcroft-Karp
        int[] pairU = new int[compCnt]; // for left side ids only (valid where side==0)
        int[] pairV = new int[compCnt]; // for right side ids only (valid where side==1)
        Arrays.fill(pairU, -1);
        Arrays.fill(pairV, -1);

        int matching = hopcroftKarp(leftNodes, g, side, pairU, pairV);

        int answer = compCnt - matching;
        System.out.println(answer);
    }

    // Hopcroft-Karp on a bipartite graph given by adjacency sets and side labels (0 left, 1 right)
    static int hopcroftKarp(List<Integer> leftNodes, List<HashSet<Integer>> g, int[] side,
                            int[] pairU, int[] pairV) {
        // Build level array only for left side
        int INF = 1 << 29;
        int[] dist = new int[pairU.length];

        int matching = 0;
        while (bfs(leftNodes, g, side, pairU, pairV, dist, INF)) {
            for (int u : leftNodes) {
                if (pairU[u] == -1) {
                    if (dfs(u, g, side, pairU, pairV, dist)) matching++;
                }
            }
        }
        return matching;
    }

    static boolean bfs(List<Integer> leftNodes, List<HashSet<Integer>> g, int[] side,
                       int[] pairU, int[] pairV, int[] dist, int INF) {
        ArrayDeque<Integer> q = new ArrayDeque<>();
        Arrays.fill(dist, INF);
        for (int u : leftNodes) {
            if (pairU[u] == -1) { dist[u] = 0; q.add(u); }
        }
        boolean reachableFreeV = false;
        while (!q.isEmpty()) {
            int u = q.poll();
            for (int v : g.get(u)) {
                if (side[v] != 1) continue;
                int pu = pairV[v];
                if (pu != -1 && dist[pu] == INF) {
                    dist[pu] = dist[u] + 1;
                    q.add(pu);
                }
                if (pu == -1) reachableFreeV = true;
            }
        }
        return reachableFreeV;
    }

    static boolean dfs(int u, List<HashSet<Integer>> g, int[] side,
                       int[] pairU, int[] pairV, int[] dist) {
        for (int v : g.get(u)) {
            if (side[v] != 1) continue;
            int pu = pairV[v];
            if (pu == -1 || (dist[pu] == dist[u] + 1 && dfs(pu, g, side, pairU, pairV, dist))) {
                pairU[u] = v;
                pairV[v] = u;
                return true;
            }
        }
        dist[u] = Integer.MAX_VALUE / 2;
        return false;
    }
}
