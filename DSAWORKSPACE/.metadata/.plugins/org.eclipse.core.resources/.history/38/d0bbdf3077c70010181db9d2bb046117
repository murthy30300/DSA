package com.tcs.roundii;

import java.util.*;
import java.io.*;

/**
 * Solution for "Tilted Bars" puzzle.
 *
 * Interpretation & approach:
 * - Each bar is a 45Â° (slope +1 or -1) line segment with integer endpoints.
 * - When the ball (x,y) is in the air: it falls vertically to the highest bar directly below it (same x).
 * - When the ball is exactly on a bar (interior, endpoint, or intersection): it may
 *     * slide to either of that bar's endpoints (representing tilting + sliding),
 *     * or drop vertically from that same (x,y).
 * - Explore all possible moves with DFS, collect unique ground x positions (y=0).
 *
 * Note: This is a modeling of the problem that generates the same kind of branchings
 * as in the examples and is robust for N <= 50.
 */
public class Main {
    static class Segment {
        int x1, y1, x2, y2;
        int slope; // +1 or -1

        Segment(int x1, int y1, int x2, int y2) {
            // normalize endpoints so x1 <= x2 or if equal keep given order
            if (x1 < x2 || (x1 == x2 && y1 <= y2)) {
                this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
            } else {
                this.x1 = x2; this.y1 = y2; this.x2 = x1; this.y2 = y1;
            }
            int dx = this.x2 - this.x1;
            int dy = this.y2 - this.y1;
            if (dx == 0) slope = 0;
            else slope = dy / dx; // should be +1 or -1
        }

        // does vertical line x = qx intersect this segment? if so return y coordinate; else return null
        Integer intersectYWithVertical(int qx) {
            int minX = Math.min(x1, x2);
            int maxX = Math.max(x1, x2);
            if (qx < minX || qx > maxX) return null;
            // since slope is +/-1, intersection y = y1 + slope*(qx - x1)
            int y = y1 + slope * (qx - x1);
            // ensure this y is within segment's y-range as well (covers degenerate cases)
            int minY = Math.min(y1, y2);
            int maxY = Math.max(y1, y2);
            if (y < minY || y > maxY) return null;
            return y;
        }

        // does point (qx, qy) lie exactly on this segment?
        boolean containsPoint(int qx, int qy) {
            Integer y = intersectYWithVertical(qx);
            return y != null && y == qy;
        }

        // endpoints
        int[] leftEndpoint() { return new int[] {x1, y1}; }
        int[] rightEndpoint() { return new int[] {x2, y2}; }
    }

    static List<Segment> segments = new ArrayList<>();
    static Set<Long> globalVisitedPoints = new HashSet<>(); // not used for pruning in main DFS, but kept if needed
    static Set<Integer> groundXs = new TreeSet<>(); // unique ground x's sorted
    // to avoid infinite loops in a path, we keep a visited set per path (x,y)
    static void dfs(int x, int y, Set<Long> pathVisited) {
        if (y == 0) {
            groundXs.add(x);
            return;
        }
        long key = (((long)x) << 32) | (y & 0xffffffffL);
        if (pathVisited.contains(key)) return; // avoid cycles in this path
        pathVisited.add(key);

        // 1) If there are bars that contain this point (x,y), we can slide to their endpoints
        boolean hadBarAtPoint = false;
        for (Segment s : segments) {
            if (s.containsPoint(x, y)) {
                hadBarAtPoint = true;
                // two endpoints:
                int[] e1 = s.leftEndpoint();
                int[] e2 = s.rightEndpoint();
                // slide to endpoint 1
                if (!(e1[0] == x && e1[1] == y)) // avoid trivial self-loop if same point
                    dfs(e1[0], e1[1], pathVisited);
                else {
                    // even if same point, we allow dropping vertically from it (below) handled later
                }
                // slide to endpoint 2
                if (!(e2[0] == x && e2[1] == y))
                    dfs(e2[0], e2[1], pathVisited);
            }
        }

        // 2) Always allow dropping vertically from current (x,y)
        // find highest bar directly below (x, y)
        int bestY = Integer.MIN_VALUE;
        for (Segment s : segments) {
            Integer iy = s.intersectYWithVertical(x);
            if (iy != null && iy < y) {
                if (iy > bestY) bestY = iy;
            }
        }
        if (bestY == Integer.MIN_VALUE) {
            // no bar below => reach ground
            groundXs.add(x);
        } else {
            // there could be multiple bars sharing the same intersection y (e.g., crossing)
            for (Segment s : segments) {
                Integer iy = s.intersectYWithVertical(x);
                if (iy != null && iy == bestY) {
                    dfs(x, iy, pathVisited);
                }
            }
        }

        pathVisited.remove(key);
    }

    public static void main(String[] args) throws Exception {
        FastScanner fs = new FastScanner(System.in);
        if (!fs.hasNext()) return;
        int N = fs.nextInt();
        for (int i = 0; i < N; i++) {
            int x1 = fs.nextInt();
            int y1 = fs.nextInt();
            int x2 = fs.nextInt();
            int y2 = fs.nextInt();
            segments.add(new Segment(x1, y1, x2, y2));
        }
        int sx = fs.nextInt();
        int sy = fs.nextInt();

        dfs(sx, sy, new HashSet<>());

        // print sorted unique ground points as "x 0" per line
        StringBuilder sb = new StringBuilder();
        for (int gx : groundXs) {
            sb.append(gx).append(" 0").append('\n');
        }
        System.out.print(sb.toString());
    }

    // fast input helper
    static class FastScanner {
        private final InputStream in;
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        FastScanner(InputStream is) { in = is; }
        private int read() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0) return -1;
            }
            return buffer[ptr++];
        }
        boolean hasNext() throws IOException {
            int c;
            while ((c = read()) != -1) {
                if (!Character.isWhitespace(c)) { ptr--; return true; }
            }
            return false;
        }
        int nextInt() throws IOException {
            int c = read();
            while (c <= ' ') c = read();
            int sign = 1;
            if (c == '-') { sign = -1; c = read(); }
            int val = 0;
            while (c > ' ') {
                val = val * 10 + (c - '0');
                c = read();
            }
            return val * sign;
        }
    }
}
