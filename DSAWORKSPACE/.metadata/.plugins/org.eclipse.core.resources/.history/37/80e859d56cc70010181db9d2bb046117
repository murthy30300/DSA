//package com.tcs.roundii;

import java.io.*;
import java.util.*;


public class MinimumHoles {
    static class Segment {
        int x1, y1, x2, y2;
        boolean vertical() { return x1 == x2; }
        boolean horizontal() { return y1 == y2; }
    }

    static class Candidate {
        int xiIndex, yjIndex; // location in the coordinate grid
        BitSet cover;         // cells covered by this candidate
        Candidate(int xi, int yj, int cells) {
            xiIndex = xi; yjIndex = yj;
            cover = new BitSet(cells);
        }
    }

    int n, m;
    List<Segment> segments;
    List<Integer> xsList, ysList;
    Map<Integer,Integer> xToIdx, yToIdx;
    int cellCount;
    List<Candidate> candidates;
    List<List<Integer>> cellToCandidates; // for each cell, list of candidate indices that cover it

    int bestAnswer = Integer.MAX_VALUE;

    public static void main(String[] args) throws Exception {
        new MinimumHoles().run();
    }

    void run() throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line = br.readLine();
        if (line == null) { System.out.println("Invalid"); return; }
        String[] parts = line.trim().split("\\s+");
        if (parts.length < 2) { System.out.println("Invalid"); return; }
        try {
            n = Integer.parseInt(parts[0]);
            m = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ex) { System.out.println("Invalid"); return; }

        String sN = br.readLine();
        if (sN == null) { System.out.println("Invalid"); return; }
        int N;
        try { N = Integer.parseInt(sN.trim()); }
        catch (Exception ex) { System.out.println("Invalid"); return; }

        segments = new ArrayList<>();
        for (int i = 0; i < N; ++i) {
            String l = br.readLine();
            if (l == null) { System.out.println("Invalid"); return; }
            String[] t = l.trim().split("\\s+");
            if (t.length != 4) { System.out.println("Invalid"); return; }
            Segment seg = new Segment();
            try {
                seg.x1 = Integer.parseInt(t[0]);
                seg.y1 = Integer.parseInt(t[1]);
                seg.x2 = Integer.parseInt(t[2]);
                seg.y2 = Integer.parseInt(t[3]);
            } catch (NumberFormatException ex) {
                System.out.println("Invalid"); return;
            }
            // check axis alignment
            if (!(seg.x1 == seg.x2 || seg.y1 == seg.y2)) { System.out.println("Invalid"); return; }
            // coordinates must be inside box boundaries [0,n]x[0,m]
            if (seg.x1 < 0 || seg.x1 > n || seg.x2 < 0 || seg.x2 > n || seg.y1 < 0 || seg.y1 > m || seg.y2 < 0 || seg.y2 > m) {
                System.out.println("Invalid"); return;
            }
            // normalize endpoints
            if (seg.x1 > seg.x2 || seg.y1 > seg.y2) {
                int tx = seg.x1, ty = seg.y1;
                seg.x1 = Math.min(seg.x1, seg.x2);
                seg.x2 = Math.max(tx, seg.x2);
                seg.y1 = Math.min(seg.y1, seg.y2);
                seg.y2 = Math.max(ty, seg.y2);
            }
            segments.add(seg);
        }

        // Build unique coordinate lists
        buildCoordinateGrids();

        // Build cells
        cellCount = (xsList.size() - 1) * (ysList.size() - 1);

        // Build candidates and coverage
        buildCandidatesAndCoverage();

        // Check every cell has at least one candidate covering it
        for (int c = 0; c < cellCount; ++c) {
            if (cellToCandidates.get(c).isEmpty()) {
                // no way to place hole on partition walls for this cell
                System.out.println("Invalid");
                return;
            }
        }

        // Greedy upper bound
        BitSet all = new BitSet(cellCount); all.set(0, cellCount);
        int greedyBound = greedyCoverCount((BitSet) all.clone());
        bestAnswer = greedyBound;

        // Prepare candidate lists per cell for backtracking
        for (int i = 0; i < cellCount; ++i) {
            List<Integer> list = cellToCandidates.get(i);
            // sort candidates for each cell by their cover size descending (heuristic)
            list.sort((a, b) -> candidates.get(b).cover.cardinality() - candidates.get(a).cover.cardinality());
        }

        // Run exact backtracking search (choose uncovered cell, branch on candidates covering it)
        dfs((BitSet) all.clone(), 0);

        System.out.println(bestAnswer == Integer.MAX_VALUE ? "Invalid" : bestAnswer);
    }

    void buildCoordinateGrids() {
        TreeSet<Integer> xs = new TreeSet<>();
        TreeSet<Integer> ys = new TreeSet<>();
        xs.add(0); xs.add(n);
        ys.add(0); ys.add(m);

        for (Segment seg : segments) {
            if (seg.vertical()) {
                xs.add(seg.x1);
                ys.add(seg.y1); ys.add(seg.y2);
            } else {
                ys.add(seg.y1);
                xs.add(seg.x1); xs.add(seg.x2);
            }
        }
        xsList = new ArrayList<>(xs);
        ysList = new ArrayList<>(ys);
        xToIdx = new HashMap<>(); yToIdx = new HashMap<>();
        for (int i = 0; i < xsList.size(); ++i) xToIdx.put(xsList.get(i), i);
        for (int j = 0; j < ysList.size(); ++j) yToIdx.put(ysList.get(j), j);
    }

    void buildCandidatesAndCoverage() {
        int nx = xsList.size(), ny = ysList.size();
        int cells = (nx - 1) * (ny - 1);
        candidates = new ArrayList<>();
        cellToCandidates = new ArrayList<>();
        for (int i = 0; i < cells; ++i) cellToCandidates.add(new ArrayList<>());

        // for each grid intersection (xi,yj) check if point is on at least one partition segment
        for (int i = 0; i < nx; ++i) {
            int x = xsList.get(i);
            for (int j = 0; j < ny; ++j) {
                int y = ysList.get(j);
                boolean onPartition = false;
                for (Segment seg : segments) {
                    if (seg.vertical()) {
                        if (seg.x1 == x && y >= seg.y1 && y <= seg.y2) { onPartition = true; break; }
                    } else {
                        if (seg.y1 == y && x >= seg.x1 && x <= seg.x2) { onPartition = true; break; }
                    }
                }
                if (!onPartition) continue;

                Candidate cand = new Candidate(i, j, cells);
                // candidate lies on boundary of up to 4 adjacent cells:
                // cells with x index i-1 or i, y index j-1 or j (if those intervals exist)
                int[] dx = {-1, 0};
                int[] dy = {-1, 0};
                for (int di : dx) {
                    int xi = i + di;
                    if (xi < 0 || xi >= nx - 1) continue;
                    for (int dj : dy) {
                        int yj = j + dj;
                        if (yj < 0 || yj >= ny - 1) continue;
                        int cellIndex = xi * (ny - 1) + yj;
                        cand.cover.set(cellIndex);
                    }
                }
                // only keep candidates that cover at least one cell
                if (cand.cover.cardinality() > 0) {
                    int idx = candidates.size();
                    candidates.add(cand);
                    // update cell->candidate lists
                    BitSet bs = cand.cover;
                    for (int c = bs.nextSetBit(0); c >= 0; c = bs.nextSetBit(c+1)) {
                        cellToCandidates.get(c).add(idx);
                    }
                }
            }
        }
    }

    int greedyCoverCount(BitSet uncovered) {
        int count = 0;
        BitSet work = (BitSet) uncovered.clone();
        while (!work.isEmpty()) {
            // pick candidate covering the largest number of currently uncovered cells
            int bestIdx = -1, bestCov = -1;
            for (int i = 0; i < candidates.size(); ++i) {
                BitSet tmp = (BitSet) candidates.get(i).cover.clone();
                tmp.and(work);
                int c = tmp.cardinality();
                if (c > bestCov) { bestCov = c; bestIdx = i; }
            }
            if (bestCov <= 0) return Integer.MAX_VALUE / 2; // cannot cover remaining
            work.andNot(candidates.get(bestIdx).cover);
            count++;
        }
        return count;
    }

    void dfs(BitSet uncovered, int usedCount) {
        if (usedCount >= bestAnswer) return; // prune
        if (uncovered.isEmpty()) {
            bestAnswer = Math.min(bestAnswer, usedCount);
            return;
        }

        // lower bound: find max cover size on current uncovered
        int maxCover = 0;
        for (Candidate c : candidates) {
            BitSet tmp = (BitSet) c.cover.clone();
            tmp.and(uncovered);
            if (tmp.cardinality() > maxCover) maxCover = tmp.cardinality();
        }
        if (maxCover == 0) return; // impossible branch

        int remaining = uncovered.cardinality();
        int lowerBound = (remaining + maxCover - 1) / maxCover;
        if (usedCount + lowerBound >= bestAnswer) return; // prune

        // choose uncovered cell with fewest candidate choices (heuristic)
        int chosenCell = -1;
        int fewest = Integer.MAX_VALUE;
        for (int c = uncovered.nextSetBit(0); c >= 0; c = uncovered.nextSetBit(c+1)) {
            int options = cellToCandidates.get(c).size();
            if (options < fewest) { fewest = options; chosenCell = c; }
            if (fewest <= 1) break;
        }
        if (chosenCell == -1) return;

        // iterate over candidates that cover chosenCell. Order by effectiveness on uncovered
        List<Integer> list = new ArrayList<>(cellToCandidates.get(chosenCell));
        list.sort((a,b) -> {
            BitSet A = (BitSet) candidates.get(a).cover.clone();
            BitSet B = (BitSet) candidates.get(b).cover.clone();
            A.and(uncovered); B.and(uncovered);
            return B.cardinality() - A.cardinality();
        });

        for (int candIdx : list) {
            BitSet newUncovered = (BitSet) uncovered.clone();
            newUncovered.andNot(candidates.get(candIdx).cover);
            dfs(newUncovered, usedCount + 1);
            if (usedCount + 1 >= bestAnswer) return; // early stop if we can't beat best
        }
    }
}
