import java.io.*;
import java.util.*;

/**
 * CubemidSolver
 *
 * Reads:
 * S
 * S*S lines (S lines per layer, layers in order 0..S-1)
 * start: "layer row col"
 * goal:  "layer row col"
 *
 * Prints a single integer: minimum steps to reach goal (or -1 if unreachable).
 *
 * NOTE: The textual problem statement is a bit ambiguous about which axis
 *       corresponds to "front/back" or "upper-level" etc. This solver
 *       tries a small set of reasonable interpretations and returns the
 *       minimal distance across them. Each interpretation is documented
 *       in the code so you can select/force one if you know the exact rules.
 */
public class Cubemid {
    static class Node { int l, r, c; Node(int l, int r, int c){ this.l=l; this.r=r; this.c=c; } }
    static final Set<Character> WALKABLE = new HashSet<>(Arrays.asList('D','R','L','F','B'));

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        // read S (skip empty lines)
        while ((line = br.readLine()) != null && line.trim().isEmpty()) {}
        if (line == null) return;
        int S = Integer.parseInt(line.trim());

        char[][][] grid = new char[S][S][S]; // grid[layer][row][col]
        for (int layer = 0; layer < S; layer++) {
            for (int row = 0; row < S; row++) {
                String ln = br.readLine();
                // skip possible empty lines
                while (ln != null && ln.trim().isEmpty()) ln = br.readLine();
                if (ln == null) throw new RuntimeException("Unexpected EOF while reading grid");
                ln = ln.trim();
                if (ln.length() != S) {
                    // defensive: if spaces between chars, remove spaces
                    ln = ln.replaceAll("\\s+","");
                }
                if (ln.length() != S) throw new RuntimeException("Each grid line must have S characters");
                for (int col = 0; col < S; col++) {
                    grid[layer][row][col] = ln.charAt(col);
                }
            }
        }

        // read start
        String startLine = br.readLine();
        while (startLine != null && startLine.trim().isEmpty()) startLine = br.readLine();
        if (startLine == null) throw new RuntimeException("Missing start line");
        String[] p = startLine.trim().split("\\s+");
        int sl = Integer.parseInt(p[0]), sr = Integer.parseInt(p[1]), sc = Integer.parseInt(p[2]);

        // read goal
        String goalLine = br.readLine();
        while (goalLine != null && goalLine.trim().isEmpty()) goalLine = br.readLine();
        if (goalLine == null) throw new RuntimeException("Missing goal line");
        p = goalLine.trim().split("\\s+");
        int gl = Integer.parseInt(p[0]), gr = Integer.parseInt(p[1]), gc = Integer.parseInt(p[2]);

        // If start or goal not walkable -> no path
        if (!inBounds(sl,sr,sc,S) || !inBounds(gl,gr,gc,S) ||
            !WALKABLE.contains(grid[sl][sr][sc]) || !WALKABLE.contains(grid[gl][gr][gc])) {
            System.out.println(-1);
            return;
        }

        // We will try multiple plausible movement-interpretations.
        // Each interpretation consists of:
        //  - how 'D' maps to four orthogonal moves (we consider 3 plausible planes)
        //  - how R/L map to an "upper-level right/left" move (upper-level interpreted as either row-1 or layer-1)
        //  - F/B we interpret as layer changes (F -> layer+1, B -> layer-1) but we also try swapped sign just in case.
        //
        // D_type options:
        //  0: D allows moves in (row +/-1, col) and (row, col +/-1) i.e. movement within same layer using row & col (layer fixed)
        //  1: D allows moves in (layer +/-1, col) and (layer, col +/-1) i.e. movement using layer & col (row fixed)
        //  2: D allows moves in (layer +/-1, row) and (layer, row +/-1) i.e. movement using layer & row (col fixed)
        //
        // R_upAxis: 0 => 'upper-level' interpreted as layer-1
        //            1 => 'upper-level' interpreted as row-1
        //
        // F_dir:  +1 => F connects to layer+1, B to layer-1
        //         -1 => F connects to layer-1, B to layer+1
        //
        // For each combination we run a directed BFS where:
        //  - from 'D' we allow its 4 orthogonal moves (per D_type)
        //  - from 'R' we allow exactly one special move (to the upper-right cell as per interpretation)
        //  - from 'L' we allow exactly one special move (to the upper-left)
        //  - from 'F' we allow move to the corresponding other layer
        //  - from 'B' we allow move to corresponding other layer
        //
        // Destination must be walkable. Edges are directed (movement allowed when current cell has that connector).
        // (This is a reasonable set of directed rules based on the statement.)
        //
        // We take the minimum distance across all tried interpretations.

        int best = Integer.MAX_VALUE;
        for (int dType = 0; dType < 3; dType++) {
            for (int rUpAxis = 0; rUpAxis < 2; rUpAxis++) {
                for (int fSign : new int[]{1, -1}) {
                    int res = bfsForInterpretation(grid, S, sl,sr,sc, gl,gr,gc, dType, rUpAxis, fSign);
                    if (res >= 0 && res < best) best = res;
                }
            }
        }

        if (best == Integer.MAX_VALUE) System.out.println(-1);
        else System.out.println(best);
    }

    static boolean inBounds(int l,int r,int c,int S){
        return l>=0 && l<S && r>=0 && r<S && c>=0 && c<S;
    }

    /**
     * Run a directed BFS for one interpretation.
     *
     * dType: 0/1/2 as explained above
     * rUpAxis: 0 -> upper-level = layer-1 ; 1 -> upper-level = row-1
     * fSign: +1 or -1 for whether F -> layer+1 (sign=+1) or F -> layer-1 (sign=-1)
     *
     * Returns shortest steps or -1 if unreachable.
     */
    static int bfsForInterpretation(char[][][] grid, int S,
                                    int sl, int sr, int sc,
                                    int gl, int gr, int gc,
                                    int dType, int rUpAxis, int fSign) {
        boolean[][][] seen = new boolean[S][S][S];
        ArrayDeque<int[]> q = new ArrayDeque<>();
        q.add(new int[]{sl,sr,sc,0});
        seen[sl][sr][sc] = true;

        while (!q.isEmpty()) {
            int[] cur = q.pollFirst();
            int l = cur[0], r = cur[1], c = cur[2], dist = cur[3];
            if (l==gl && r==gr && c==gc) return dist;
            char t = grid[l][r][c];
            if (!WALKABLE.contains(t)) continue;

            // 1) D-type four orthogonal moves (if current tile is 'D')
            if (t == 'D') {
                int[][] moves = getDMovesByType(dType);
                for (int[] mv : moves) {
                    int nl = l + mv[0], nr = r + mv[1], nc = c + mv[2];
                    if (inBounds(nl,nr,nc,S) && WALKABLE.contains(grid[nl][nr][nc]) && !seen[nl][nr][nc]) {
                        seen[nl][nr][nc] = true;
                        q.add(new int[]{nl,nr,nc,dist+1});
                    }
                }
            }

            // 2) F/B connections (layer jump) - directed
            if (t == 'F' || t == 'B') {
                int dir = (t == 'F') ? fSign : -fSign; // e.g. fSign=+1 => F->+1, B->-1
                int nl = l + dir, nr = r, nc = c;
                if (inBounds(nl,nr,nc,S) && WALKABLE.contains(grid[nl][nr][nc]) && !seen[nl][nr][nc]) {
                    seen[nl][nr][nc] = true;
                    q.add(new int[]{nl,nr,nc,dist+1});
                }
            }

            // 3) R / L (upper-level right/left)
            if (t == 'R' || t == 'L') {
                // "upper-level" interpreted based on rUpAxis
                int nl = l, nr = r, nc = c;
                if (rUpAxis == 0) {
                    // upper-level => layer-1
                    nl = l - 1;
                    nr = r;
                    nc = (t == 'R') ? (c + 1) : (c - 1);
                } else {
                    // upper-level => row-1
                    nl = l;
                    nr = r - 1;
                    nc = (t == 'R') ? (c + 1) : (c - 1);
                }
                if (inBounds(nl,nr,nc,S) && WALKABLE.contains(grid[nl][nr][nc]) && !seen[nl][nr][nc]) {
                    seen[nl][nr][nc] = true;
                    q.add(new int[]{nl,nr,nc,dist+1});
                }
            }

            // Note: We intentionally treat movements as *directed* from the current cell's connector.
            // That matches statements like "From a chamber with a flat floor (D), the team can move in any of the 4 directions..."
            // and "R - Connects the current floor to upper-level right floor" meaning R provides that directed connection.
        }
        return -1;
    }

    // Return four relative moves for D depending on interpretation type (dl, dr, dc)
    // dType:
    // 0: plane = (row, col) within same layer  => (0, +1/ -1, 0) and (0, 0, +1/-1)
    // 1: plane = (layer, col) with row fixed    => (+1/ -1, 0, 0) and (0, 0, +1/-1)
    // 2: plane = (layer, row) with col fixed    => (+1/ -1, 0, 0) and (0, +1/-1, 0)
    static int[][] getDMovesByType(int dType) {
        if (dType == 0) {
            return new int[][] {
                {0, +1, 0},
                {0, -1, 0},
                {0, 0, +1},
                {0, 0, -1}
            };
        } else if (dType == 1) {
            return new int[][] {
                {+1, 0, 0},
                {-1, 0, 0},
                {0, 0, +1},
                {0, 0, -1}
            };
        } else { // dType == 2
            return new int[][] {
                {+1, 0, 0},
                {-1, 0, 0},
                {0, +1, 0},
                {0, -1, 0}
            };
        }
    }
}
